# # N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램
# # 다만 걷는 거리가 같을 때 아래층 방 더 선호
# # 입력
# # T : 개의 테스트 데이터 -> 몇개의 데이터를 입력할 것인지

# # 층 수 ,각 층의 방 수, 몇 번째 손님인지
# # H     W           N

# # 2차원 배열 활용 -> 처리시간에 대한 문제가 있을 수 있음
# # 2차원 배열을 활용하지 않는다면?

# # TC
# # T : 2, 2개의 2차원 배열을 만들 수 있음

# h, w, n = map(int, input().split())

# # 반복횟수는 n
# # 만약 H를 6까지 도달 했으면 H는 1로 돌아오고ㅣ(이때의 층수를 기억),
# #  호수를 나타내는 문자를 2로 바꿔주기(이때의 호수를 기억)
# # n의 반복횟수를 돌면 그 층, 호수 값을 문자열로 더해 return
# # 하지만 호수를 나타내는 값이 W와 같아진다면 종료

# currentH = 0 # 현재의 층수
# currentW = 0 # 현재의 호수

# for _ in range(n):
#     currentH += 1 # 층수 up
#     currentW += 1
#     # 만약 현재의 층수, 호수가 입력한 층수보다 높다면 현재의 층수를 0으로 초기화
#     if currentH > h and currentW > w: 
#         currentH = 0
#         currentW = 0

####################################################################################

# 2차원 배열을 초기화 시켜주는 문제가 아니다 잘못생각함

# 이 문제의 핵심
# N % H = 층수
# N / H + 1 = 호수
# 예외 : 나누어 떨어질 때는 층수를 H, 호수를 하나 줄여줘야 한다

num = int(input())

for i in range(num):
    H, W, N = map(int, input().split())
    floor = N % H # 층수
    room = N // H + 1 # 호수
    if floor == 0:
        room -= 1
        floor = H
    print(floor*100 + room)

